<!DOCTYPE html>
<html lang="en">
	<head>
		<title>WebKenKen</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000000;
				font-family:Monospace;
				font-size:15px;
				text-align:center;

				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}

		</style>
	</head>
	<body>
		<h1>WebKenKen</h1>
		Size:
		<select id="sizeSelect">
			<option selected>3</option>
			<option>4</option>
			<option>5</option>
			<option>6</option>
		</select>
		<input type="button" onclick="generateBoard()" value="Create"></input>
		<input type="button" onclick="solve()" value="Solve"></input>
		<input type="button" onclick="hide()" value="Hide"></input>
		<div id="container"></div>

		<script>
		var container;
		var table;
		var size;
		var board;
		var region;
		var cellElems;
		var operElems;
		var operators;
		var memos;
		var selectedCell = null;
		var selectedCoords = null;
		var messageElem;

		function iterateCells(func){
			for(var iy = 0; iy < size; iy++){
				for(var ix = 0; ix < size; ix++){
					func(ix, iy);
				}
			}
		}

		function solve(){
			iterateCells(function(ix, iy){
				var valueDiv = document.getElementById('r' + iy + 'c' + ix);
				valueDiv.innerHTML = board[ix + iy * size];
				valueDiv.style.display = 'block';
			});
		}

		function hide(){
			iterateCells(function(ix, iy){
				var valueDiv = document.getElementById('r' + iy + 'c' + ix);
				valueDiv.style.display = 'none';
			});
		}

		function checkAnswer(){
			var correct = true;
			iterateCells(function(ix, iy){
				var valueDiv = document.getElementById('r' + iy + 'c' + ix);
				// String based comparison because valueDiv may contain whitespace
				if(board[ix + iy * size].toString() !== valueDiv.innerHTML)
					correct = false;
			});
			if(correct){
				messageElem.innerHTML = "Congratulations!<br>You've solved the puzzle!";
			}
		}

		window.onload = function(){
			generateBoard();
		}

		function generateBoard(){
			var sizeStr = document.getElementById("sizeSelect").value;
			size = parseInt(sizeStr);
			board = new Array(size * size);
			region = new Array(size * size);
			memos = new Array(size * size);
			cellElems = new Array(size * size);
			operElems = new Array(size * size);
			operators = [];

			// The containers are nested so that the inner container can be easily
			// discarded to recreate the whole game.
			var outerContainer = document.getElementById("container");
			if(container)
				outerContainer.removeChild(container);
			container = document.createElement("div");
			outerContainer.appendChild(container);

			table = document.createElement("div");
			table.style.borderStyle = 'solid';
			table.style.borderWidth = '1px';
			table.style.borderColor = 'red';
			table.style.position = 'relative';
			table.style.left = '50%';
			table.style.width = (size * 4. + 0.1) + 'em';
			table.style.height = (size * 4. + 0.1) + 'em';
			var latinSquareTries = 0;
			for(var iy = 0; iy < size; iy++){
				for(var tries = 0; tries < 1000; tries++){
					latinSquareTries++;
					if((function(){
						var next = board.slice(0);
						// First, build an array of all available numbers for a row.
						// We will randomly pick and delete from this array to enumerate permutation.
						var avail = [];
						for(var i = 0; i < size; i++)
							avail.push(i+1);
						for(var ix = 0; ix < size; ix++){
							// Create a clone of available numbers array and delete numbers already used in column.
							// This will greatly reduce the chance of invalid permutation, but it's not like
							// it will never happen, so we still need to retry if permutation fails.
							var vavail = avail.slice(0);
							for(var j = 0; j < iy; j++){
								var vidx = vavail.indexOf(board[ix + j * size]);
								if(0 <= vidx)
									vavail.splice(vidx, 1);
							}
							// There's a possibility of using up all available numbers, in which case we should
							// retry for this row.
							// If we'd be sure to check every possible permutations, rather than retry with exactly
							// the same conditions and new random numbers, we could use recursive calls to
							// track all paths like the labeling algorithm, but it seems unnecessary around size 6.
							if(vavail.length === 0)
								return false;
							var idx = Math.floor(Math.random() * vavail.length);
							if(idx < 0)
								return false;
							next[ix + iy * size] = vavail[idx];
							// The original available numbers array should always contain numbers picked from reduced array.
							avail.splice(avail.indexOf(vavail[idx]), 1);
						}
						board = next;
						return true;
					})())
						break;
				}
			}

			var colors = [
				'#aaa',
				'#faa',
				'#afa',
				'#aaf',
				'#ffa',
				'#aff',
				'#faf',
				'#f00',
				'#0c0',
				'#c0c',
				'#0ff',
				'#07f',
				'#0f7',
				'#f40',
				'#7f0',
				'#f07',
				'#70f',
			]

			var allTries = 0;

			function paintCells(region){
				for(var y = 0; y < size; y++){
					for(var x = 0; x < size; x++){
						cellElems[x + y * size].style.backgroundColor = colors[region[x + y * size] % colors.length];
					}
				}
			}

			/// Check if the region definition has a duplicate row or column,
			/// in which case it is clear that the problem cannot be solved
			/// with single answer.  You could swap these rows or columns to
			/// obtain another solution.
			/// Not having a duplicate row or column does not mean it is
			/// solvable, though.  This is dirty heuristic to quickly discard
			/// obviously bad problems.
			function checkSolvability(region){
				function sameVector(a,b){
					for(var i = 0; i < a.length; i++)
						if(a[i] !== b[i])
							return false;
					return true;
				}
				function columnVector(region, x){
					var ret = [];
					for(var i = 0; i < size; i++)
						ret.push(region[x + i * size]);
					return ret;
				}
				for(var iy = 0; iy < size; iy++){
					var row = region.slice(iy * size, (iy + 1) * size);
					for(var jy = iy + 1; jy < size; jy++)
						if(sameVector(row, region.slice(jy * size, (jy + 1) * size)))
							return false;
				}
				for(var ix = 0; ix < size; ix++){
					var col = columnVector(region, ix);
					for(var jx = ix + 1; jx < size; jx++)
						if(sameVector(col, columnVector(region, jx)))
							return false;
				}

				setOperators(region);

				function showField(x, y){
					var memoElem = document.getElementById('memo_r' + y + 'c' + x);
					memoElem.style.display = 'block';
					memoElem.innerHTML = '';
					for(var i = 0; i < size; i++)
						if(field[x + y * size] & (1 << i))
							memoElem.innerHTML += (i + 1).toString();
				}

				var field = new Array(size * size);
				for(var iy = 0; iy < size; iy++){
					for(var ix = 0; ix < size; ix++){
						var currentSet = 0;
						for(var i = 0; i < size; i++)
							currentSet |= 1 << i;
						field[ix + iy * size] = currentSet;
						showField(ix, iy);
					}
				}
				for(var i = 0; i < operators.length; i++){
					var cellPos = [];
					iterateCells(function(ix, iy){
						if(region[ix + iy * size] === i + 1){
							cellPos.push([ix, iy]);
						}
					});
					if(cellPos.length === 0)
						break;
					if(operators[i].oper == '*'){
						for(var j = 0; j < size; j++){
							if(operators[i].product % (j + 1) !== 0){
								for(var k = 0; k < cellPos.length; k++){
									var ix = cellPos[k][0];
									var iy = cellPos[k][1];
									field[ix + iy * size] &= ~(1 << j);
									showField(ix, iy);
								}
							}
						}
					}
					if(operators[i].oper == '/'){
						var jx = cellPos[0][0];
						var jy = cellPos[0][1];
						var jfield = field[jx + jy * size];
						var jvalid = 0;
						var kx = cellPos[1][0];
						var ky = cellPos[1][1];
						var kfield = field[kx + ky * size];
						var kvalid = 0;
						for(var j = 0; j < size; j++){
							if(!(jfield & (1 << j)))
								continue;
							for(var k = 0; k < size; k++){
								if(!(kfield & (1 << k)))
									continue;
								var jv = j + 1;
								var kv = k + 1;
								if(jv < kv){
									if(kv / jv === operators[i].product){
										jvalid |= 1 << j;
										kvalid |= 1 << k;
									}
								}
								else{
									if(jv / kv === operators[i].product){
										jvalid |= 1 << j;
										kvalid |= 1 << k;
									}
								}
							}
						}

						jfield &= jvalid;
						field[jx + jy * size] = jfield;
						showField(jx, jy);
						kfield &= kvalid;
						kfield[kx + ky * size] = kfield;
						showField(kx, ky);
					}
					if(operators[i].oper == '-'){
						var jx = cellPos[0][0];
						var jy = cellPos[0][1];
						var jfield = field[jx + jy * size];
						var jvalid = 0;
						var kx = cellPos[1][0];
						var ky = cellPos[1][1];
						var kfield = field[kx + ky * size];
						var kvalid = 0;
						for(var j = 0; j < size; j++){
							if(!(jfield & (1 << j)))
								continue;
							for(var k = 0; k < size; k++){
								if(!(kfield & (1 << k)))
									continue;
								var jv = j + 1;
								var kv = k + 1;
								if(jv < kv){
									if(kv - jv === operators[i].product){
										jvalid |= 1 << j;
										kvalid |= 1 << k;
									}
								}
								else{
									if(jv - kv === operators[i].product){
										jvalid |= 1 << j;
										kvalid |= 1 << k;
									}
								}
							}
						}

						jfield &= jvalid;
						field[jx + jy * size] = jfield;
						showField(jx, jy);
						kfield &= kvalid;
						kfield[kx + ky * size] = kfield;
						showField(kx, ky);
					}
				}
				return true;
			}

			function growCells(type, region){
				function growCellSingle(x, y, type, region, cells){
					allTries++;
					var next = region.slice(0);
					var avail = [];
					if(2 <= cells){
						avail.push({func: function(){
							var ret = growCells(type, region);
							if(ret)
								return ret;
							paintCells(region);
						}, data: null,
						weight: 3}); // Prioritize small regions by weighting option for creating new regions
					}
					next[x + y * size] = type;
					if(cells < 3){
						var deltax = [-1, 0, 1, 0];
						var deltay = [0, -1, 0, 1];
						for(var i = 0; i < 4; i++){
							var newx = x + deltax[i];
							var newy = y + deltay[i];
							if(newx < 0 || size <= newx || newy < 0 || size <= newy)
								continue;
							if(region[newx + newy * size])
								continue;
							avail.push({func: function(data){
								paintCells(next);
								return growCellSingle(data[0], data[1], type, next, cells + 1);
								},
								data: [newx, newy],
								weight: 1});
						}
					}

					// Backtrack all available options recursively
					while(avail.length){
						// Options have weights, so we first measure total weight
						var allWeight = 0;
						for(var j = 0; j < avail.length; j++)
							allWeight += avail[j].weight;
						// Obtain value for selecting an option
						var val = Math.random() * allWeight;
						// Accumulate weights and find the corresponding option
						allWeight = 0;
						for(var j = 0; j < avail.length; j++){
							allWeight += avail[j].weight;
							if(val < allWeight){
								ret = avail[j].func(avail[j].data);
								if(ret)
									return ret;
								avail.splice(j, 1);
								break;
							}
						}
					}
					// At least 2 cells are required
					if(cells < 1)
						return null;
					return growCells(type, next);
				}

				function growCellTry(type, region){

					for(var iy = 0; iy < size; iy++){
						for(var ix = 0; ix < size; ix++){
							if(region[ix + iy * size] === 0){
								return growCellSingle(ix, iy, ++type, region, 0);
							}
						}
					}
					if(iy == size && checkSolvability(region))
						return region;
					else
						return false;
				}

				var numTries = 1;
				for(var tries = 0; tries < numTries; tries++){
					var ret = growCellTry(type, region);
					if(ret)
						return ret;
				}
				// If all tries fail, return null
				return null;
			}

			for(var iy = 0; iy < size; iy++){
				for(var ix = 0; ix < size; ix++){
					region[ix + iy * size] = 0;
				}
			}

			function selectCell(sel){
				selectedCell = sel;
				iterateCells(function(ix, iy){
					if(cellElems[ix + iy * size] === sel){
						cellElems[ix + iy * size].style.border = '2px blue solid';
						selectedCoords = [ix, iy];
					}
					else
						cellElems[ix + iy * size].style.border = '1px black solid';
				})
			}

			messageElem = document.createElement('div');
			container.appendChild(messageElem);
			messageElem.style.fontFamily = 'Sans-serif';
			messageElem.style.fontSize = '20pt';
			messageElem.style.position = 'relative';
			messageElem.style.color = 'red';

			container.appendChild(table);
			for(var iy = 0; iy < size; iy++){
				for(var ix = 0; ix < size; ix++){
					var cell = document.createElement("div");
					cellElems[ix + iy * size] = cell;
					cell.innerHTML = "";
					//cell.style.backgroundColor = colors[region[ix + iy * size] % 4];
					cell.style.width = '3.5em';
					cell.style.height = '3.5em';
					cell.style.position = 'absolute';
					cell.style.top = (4.0 * iy + 0.2) + 'em';
					cell.style.left = (4.0 * ix + 0.2) + 'em';
					cell.style.verticalAlign = 'middle';
					cell.onclick = function(){
						selectCell(this);
					}
					table.appendChild(cell);

					var operElem = document.createElement('div');
					operElem.style.position = 'absolute';
					operElem.style.top = '0px';
					cell.appendChild(operElem);
					operElems[ix + iy * size] = operElem;

					var valueDiv = document.createElement("div");
					valueDiv.id = 'r' + iy + 'c' + ix;
					valueDiv.style.fontSize = '30px';
					valueDiv.style.position = 'absolute';
					valueDiv.style.top = '50%';
					valueDiv.style.width = '100%';
					valueDiv.style.textAlign = 'center';
					valueDiv.innerHTML = '&nbsp;';
					cell.appendChild(valueDiv);
					var r = valueDiv.getBoundingClientRect();
					valueDiv.style.marginTop = (-r.height / 2) + 'px';
					valueDiv.style.display = 'none';

					var memoElem = document.createElement("div");
					memoElem.id = 'memo_r' + iy + 'c' + ix;
					memoElem.style.fontSize = '12px';
					memoElem.style.position = 'relative';
					memoElem.style.top = '100%';
					memoElem.style.marginTop = '-1em';
					cell.appendChild(memoElem);
				}
			}
			// Set the margin after contents are initialized
			table.style.marginLeft = (-table.getBoundingClientRect().width / 2) + 'px';

			selectCell(null);

			function setOperators(region){
				operators = [];
				for(var i = 1; i < 100; i++){
					var topLeftCell = null;
					var top, left;
					var first;
					var cellValues = [];
					iterateCells(function(ix, iy){
						if(region[ix + iy * size] === i){
							if(cellValues.length === 0){
								top = iy;
								left = ix;
								topLeftCell = cellElems[ix + iy * size];
								first = board[ix + iy * size];
							}
							cellValues.push(board[ix + iy * size]);
						}
					});
					if(cellValues.length === 0)
						break;
					var avail = ['*', '+'];
					if(cellValues.length === 2)
						avail.push('-');
					// If numbers are not dividable to each other, we can't use it for division operator
					if(cellValues.length === 2 && (cellValues[0] % cellValues[1] === 0 || cellValues[1] % cellValues[0] === 0))
						avail.push('/');
					var index = Math.floor(Math.random() * avail.length);
					var oper = avail[index];
					var product;
					if(oper === '+'){
						product = 0;
						for(var j = 0; j < cellValues.length; j++)
							product += cellValues[j];
					}
					else if(oper === '*'){
						product = 1;
						for(var j = 0; j < cellValues.length; j++)
							product *= cellValues[j];
					}
					else if(oper === '-'){
						product = Math.abs(cellValues[1] - cellValues[0]);
					}
					else if(oper === '/'){
						product = cellValues[0] < cellValues[1] ? cellValues[1] / cellValues[0] : cellValues[0] / cellValues[1];
					}
					var operElem = operElems[left + top * size];
					operElem.innerHTML = product + avail[index];
					operElem.style.position = 'absolute';
					operElem.style.top = '0px';
					operators.push({
						oper: oper,
						product: product,
					})
				}
			}

			var ret = growCells(0, region);
			if(ret){
				region = ret;
				paintCells(region);
			}

			var answers = document.createElement('div');
			container.appendChild(answers);
			answers.style.fontSize = '25px';
			answers.style.padding = '10px';
			answers.innerHTML = 'Ans: ';

			function addAnswer(str){
				var a = document.createElement('span');
				answers.appendChild(a);
				a.innerHTML = str;
				a.style.marginRight = '10px';
				a.style.border = '1px solid blue';
				a.style.padding = '5px';
				a.onclick = function(){
					if(selectedCoords){
						var valueDiv = document.getElementById('r' + selectedCoords[1] + 'c' + selectedCoords[0]);
						valueDiv.style.display = 'block';
						valueDiv.innerHTML = this.innerHTML;
						checkAnswer();
					}
				};
			}

			for(var i = 0; i < size; i++){
				addAnswer((i + 1).toString());
			}
			addAnswer('&nbsp;');

			var memoContainer = document.createElement('div');
			container.appendChild(memoContainer);
			memoContainer.style.fontSize = '15px';
			memoContainer.style.padding = '10px';
			memoContainer.innerHTML = 'Memo: ';
			for(var i = 0; i < size; i++){
				var a = document.createElement('span');
				memoContainer.appendChild(a);
				a.innerHTML = (i + 1).toString();
				a.style.marginRight = '10px';
				a.style.border = '1px solid blue';
				a.style.padding = '5px';
				a.onclick = function(){
					if(selectedCoords){
						var memoElem = document.getElementById('memo_r' + selectedCoords[1] + 'c' + selectedCoords[0]);
						memoElem.style.display = 'block';
						var currentSet = memos[selectedCoords[0] + selectedCoords[1] * size] || [];
						var idx = currentSet.indexOf(this.innerHTML);
						if(0 <= idx)
							currentSet.splice(idx, 1);
						else {
							currentSet.push(this.innerHTML);
							currentSet.sort();
						}
						memos[selectedCoords[0] + selectedCoords[1] * size] = currentSet;
						memoElem.innerHTML = '';
						for(var j = 0; j < currentSet.length; j++)
							memoElem.innerHTML += currentSet[j];
					}
				}
			}

			var debugText = document.createElement('div');
			debugText.innerHTML = 'labelTries: ' + allTries.toString() + ', latinSquareTries: ' + latinSquareTries.toString();
			container.appendChild(debugText);
		};

		</script>

	</body>
</html>
